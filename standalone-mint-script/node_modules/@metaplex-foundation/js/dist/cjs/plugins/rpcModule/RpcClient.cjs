'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Signer = require('../../types/Signer.cjs');
var RpcError = require('../../errors/RpcError.cjs');
var Amount = require('../../types/Amount.cjs');
var Program = require('../../types/Program.cjs');
var ProgramError = require('../../errors/ProgramError.cjs');
var common = require('../../utils/common.cjs');

/**
 * @group Modules
 */
class RpcClient {
  constructor(metaplex) {
    this.metaplex = metaplex;
  }

  async prepareTransaction(transaction, signers) {
    let blockhashWithExpiryBlockHeight;

    if (!('records' in transaction) && transaction.recentBlockhash && transaction.lastValidBlockHeight) {
      blockhashWithExpiryBlockHeight = {
        blockhash: transaction.recentBlockhash,
        lastValidBlockHeight: transaction.lastValidBlockHeight
      };
    } else {
      blockhashWithExpiryBlockHeight = await this.getLatestBlockhash();
    }

    if ('records' in transaction) {
      signers = [...transaction.getSigners(), ...signers];
      transaction = transaction.toTransaction(blockhashWithExpiryBlockHeight);
    }

    return {
      transaction,
      signers,
      blockhashWithExpiryBlockHeight
    };
  }

  async signTransaction(transaction, signers) {
    const {
      keypairs,
      identities
    } = Signer.getSignerHistogram(signers); // Keypair signers.

    if (keypairs.length > 0) {
      transaction.partialSign(...keypairs);
    } // Identity signers.


    for (let i = 0; i < identities.length; i++) {
      await identities[i].signTransaction(transaction);
    }

    return transaction;
  }

  async sendTransaction(transaction, sendOptions = {}, signers = []) {
    const prepared = await this.prepareTransaction(transaction, signers);
    transaction = prepared.transaction;
    signers = prepared.signers;
    const defaultFeePayer = this.getDefaultFeePayer();

    if (!transaction.feePayer && defaultFeePayer) {
      transaction.feePayer = defaultFeePayer.publicKey;
      signers = [defaultFeePayer, ...signers];
    }

    transaction = await this.signTransaction(transaction, signers);
    const rawTransaction = transaction.serialize();

    try {
      return await this.metaplex.connection.sendRawTransaction(rawTransaction, sendOptions);
    } catch (error) {
      throw this.parseProgramError(error, transaction);
    }
  }

  async confirmTransaction(signature, blockhashWithExpiryBlockHeight, commitment) {
    let rpcResponse;

    try {
      rpcResponse = await this.metaplex.connection.confirmTransaction({
        signature,
        ...blockhashWithExpiryBlockHeight
      }, commitment);
    } catch (error) {
      throw new RpcError.FailedToConfirmTransactionError(error);
    }

    if (rpcResponse.value.err) {
      throw new RpcError.FailedToConfirmTransactionWithResponseError(rpcResponse);
    }

    return rpcResponse;
  }

  async sendAndConfirmTransaction(transaction, confirmOptions, signers = []) {
    const prepared = await this.prepareTransaction(transaction, signers);
    const {
      blockhashWithExpiryBlockHeight
    } = prepared;
    transaction = prepared.transaction;
    signers = prepared.signers;
    const signature = await this.sendTransaction(transaction, confirmOptions, signers);
    const confirmResponse = await this.confirmTransaction(signature, blockhashWithExpiryBlockHeight, confirmOptions === null || confirmOptions === void 0 ? void 0 : confirmOptions.commitment);
    return {
      signature,
      confirmResponse,
      ...blockhashWithExpiryBlockHeight
    };
  }

  async getAccount(publicKey, commitment) {
    const accountInfo = await this.metaplex.connection.getAccountInfo(publicKey, commitment);
    return this.getUnparsedMaybeAccount(publicKey, accountInfo);
  }

  async accountExists(publicKey, commitment) {
    const balance = await this.metaplex.connection.getBalance(publicKey, commitment);
    return balance > 0;
  }

  async getMultipleAccounts(publicKeys, commitment) {
    const accountInfos = await this.metaplex.connection.getMultipleAccountsInfo(publicKeys, commitment);
    return common.zipMap(publicKeys, accountInfos, (publicKey, accountInfo) => {
      return this.getUnparsedMaybeAccount(publicKey, accountInfo);
    });
  }

  async getProgramAccounts(programId, configOrCommitment) {
    const accounts = await this.metaplex.connection.getProgramAccounts(programId, configOrCommitment);
    return accounts.map(({
      pubkey,
      account
    }) => ({ ...account,
      publicKey: pubkey,
      lamports: Amount.lamports(account.lamports)
    }));
  }

  async airdrop(publicKey, amount, commitment) {
    Amount.assertSol(amount);
    const signature = await this.metaplex.connection.requestAirdrop(publicKey, amount.basisPoints.toNumber());
    const blockhashWithExpiryBlockHeight = await this.getLatestBlockhash();
    const confirmResponse = await this.confirmTransaction(signature, blockhashWithExpiryBlockHeight, commitment);
    return {
      signature,
      confirmResponse,
      ...blockhashWithExpiryBlockHeight
    };
  }

  async getBalance(publicKey, commitment) {
    const balance = await this.metaplex.connection.getBalance(publicKey, commitment);
    return Amount.lamports(balance);
  }

  async getRent(bytes, commitment) {
    const rent = await this.metaplex.connection.getMinimumBalanceForRentExemption(bytes, commitment);
    return Amount.lamports(rent);
  }

  async getLatestBlockhash(commitmentOrConfig = 'finalized') {
    return this.metaplex.connection.getLatestBlockhash(commitmentOrConfig);
  }

  getSolanaExporerUrl(signature) {
    let clusterParam = '';

    switch (this.metaplex.cluster) {
      case 'devnet':
        clusterParam = '?cluster=devnet';
        break;

      case 'testnet':
        clusterParam = '?cluster=testnet';
        break;

      case 'localnet':
      case 'custom':
        const url = encodeURIComponent(this.metaplex.connection.rpcEndpoint);
        clusterParam = `?cluster=custom&customUrl=${url}`;
        break;
    }

    return `https://explorer.solana.com/tx/${signature}${clusterParam}`;
  }

  setDefaultFeePayer(payer) {
    this.defaultFeePayer = payer;
    return this;
  }

  getDefaultFeePayer() {
    return this.defaultFeePayer ? this.defaultFeePayer : this.metaplex.identity();
  }

  getUnparsedMaybeAccount(publicKey, accountInfo) {
    if (!accountInfo) {
      return {
        publicKey,
        exists: false
      };
    }

    return { ...accountInfo,
      publicKey,
      exists: true,
      lamports: Amount.lamports(accountInfo.lamports)
    };
  }

  parseProgramError(error, transaction) {
    var _error$message$match$, _error$message$match, _transaction$instruct, _transaction$instruct2, _transaction$instruct3;

    // Ensure the error as logs.
    if (!Program.isErrorWithLogs(error)) {
      return new RpcError.FailedToSendTransactionError(error);
    } // Parse the instruction number.


    const regex = /Error processing Instruction (\d+):/;
    const instruction = (_error$message$match$ = (_error$message$match = error.message.match(regex)) === null || _error$message$match === void 0 ? void 0 : _error$message$match[1]) !== null && _error$message$match$ !== void 0 ? _error$message$match$ : null; // Ensure there is an instruction number given to find the program.

    if (!instruction) {
      return new RpcError.FailedToSendTransactionError(error);
    } // Get the program ID from the instruction in the transaction.


    const instructionNumber = parseInt(instruction, 10);
    const programId = (_transaction$instruct = (_transaction$instruct2 = transaction.instructions) === null || _transaction$instruct2 === void 0 ? void 0 : (_transaction$instruct3 = _transaction$instruct2[instructionNumber]) === null || _transaction$instruct3 === void 0 ? void 0 : _transaction$instruct3.programId) !== null && _transaction$instruct !== void 0 ? _transaction$instruct : null; // Ensure we were able to find a program ID for the instruction.

    if (!programId) {
      return new RpcError.FailedToSendTransactionError(error);
    } // Find a registered program if any.


    let program;

    try {
      program = this.metaplex.programs().get(programId);
    } catch (_programNotFoundError) {
      return new RpcError.FailedToSendTransactionError(error);
    } // Ensure an error resolver exists on the program.


    if (!program.errorResolver) {
      return new ProgramError.UnknownProgramError(program, error);
    } // Finally, resolve the error.


    const resolvedError = program.errorResolver(error);
    return resolvedError ? new ProgramError.ParsedProgramError(program, resolvedError) : new ProgramError.UnknownProgramError(program, error);
  }

}

exports.RpcClient = RpcClient;
//# sourceMappingURL=RpcClient.cjs.map
