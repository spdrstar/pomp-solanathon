'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../../_virtual/_rollupPluginBabelHelpers.cjs');
var buffer = require('buffer');
var beet = require('@metaplex-foundation/beet');
var constants = require('./constants.cjs');
var errors = require('./errors.cjs');
var Serializer = require('../../types/Serializer.cjs');
var common = require('../../utils/common.cjs');
var FeatureFlags = require('../../types/FeatureFlags.cjs');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var beet__namespace = /*#__PURE__*/_interopNamespace(beet);

/**
 * This client enables us to register custom guards from
 * custom Candy Guard programs and interact with them.
 *
 * @see {@link CandyGuardClient}
 * @group Module
 */
class CandyMachineGuardsClient {
  constructor(metaplex) {
    _rollupPluginBabelHelpers.defineProperty(this, "guards", []);

    this.metaplex = metaplex;
  }
  /** Registers one or many guards by providing their manifest. */


  register(...guard) {
    this.guards.push(...guard);
  }
  /** Gets the manifest of a guard using its name. */


  get(name) {
    const guard = this.guards.find(guard => guard.name === name);

    if (!guard) {
      throw new errors.UnregisteredCandyGuardError(name);
    }

    return guard;
  }
  /** Gets all registered guard manifests. */


  all() {
    return this.guards;
  }
  /**
   * Gets all guard manifests for a registered Candy Guard program.
   *
   * It fails if the manifest of any guard expected by the program
   * is not registered. Manifests are returned in the order in which
   * they are defined on the `availableGuards` property of the program.
   */


  forProgram(program = 'CandyGuardProgram') {
    const candyGuardProgram = typeof program === 'object' && 'availableGuards' in program ? program : this.metaplex.programs().get(program);
    return candyGuardProgram.availableGuards.map(name => this.get(name));
  }
  /**
   * Gets all guard manifests for the registered Candy Guard program.
   *
   * @see {@link CandyMachineGuardsClient.forProgram}
   */


  forCandyGuardProgram(programs = []) {
    const candyGuardProgram = this.metaplex.programs().getCandyGuard(programs);
    return this.forProgram(candyGuardProgram);
  }
  /** Serializes the settings of all guards and groups. */


  serializeSettings(guards, groups = [], programs = []) {
    const availableGuards = this.forCandyGuardProgram(programs);

    const serializeSet = set => {
      return availableGuards.reduce((acc, guard) => {
        var _set$guard$name;

        const value = (_set$guard$name = set[guard.name]) !== null && _set$guard$name !== void 0 ? _set$guard$name : null;
        const optionPrefix = buffer.Buffer.from([value ? 1 : 0]);
        const newBuffer = value ? Serializer.serialize(value, guard.settingsSerializer) : buffer.Buffer.from([]);
        acc = buffer.Buffer.concat([acc, optionPrefix, newBuffer]);
        return acc;
      }, buffer.Buffer.from([]));
    };

    let buffer$1 = serializeSet(guards);

    if (groups.length > 0) {
      const groupCountBuffer = buffer.Buffer.alloc(5);
      beet__namespace.u8.write(groupCountBuffer, 0, 1);
      beet__namespace.u32.write(groupCountBuffer, 1, groups.length);
      buffer$1 = buffer.Buffer.concat([buffer$1, groupCountBuffer]);
    } else {
      buffer$1 = buffer.Buffer.concat([buffer$1, buffer.Buffer.from([0])]);
    }

    groups.forEach(group => {
      const labelBuffer = buffer.Buffer.alloc(4 + constants.CANDY_GUARD_LABEL_SIZE);
      beet__namespace.fixedSizeUtf8String(constants.CANDY_GUARD_LABEL_SIZE).write(labelBuffer, 0, common.padEmptyChars(group.label, constants.CANDY_GUARD_LABEL_SIZE));
      buffer$1 = buffer.Buffer.concat([buffer$1, labelBuffer, serializeSet(group.guards)]);
    });
    return buffer$1;
  }
  /** Deserializes the settings of all guards and groups. */


  deserializeSettings(buffer, program = 'CandyGuardProgram') {
    const availableGuards = this.forProgram(program);

    const deserializeSet = () => {
      const serializedFeatures = buffer.slice(0, 8);
      const features = FeatureFlags.deserializeFeatureFlags(serializedFeatures, 64)[0];
      buffer = buffer.slice(8);
      return availableGuards.reduce((acc, guard, index) => {
        var _features$index;

        const isEnabled = (_features$index = features[index]) !== null && _features$index !== void 0 ? _features$index : false;
        acc[guard.name] = null;
        if (!isEnabled) return acc;
        const [settings] = Serializer.deserialize(buffer, guard.settingsSerializer);
        buffer = buffer.slice(guard.settingsBytes);
        acc[guard.name] = settings;
        return acc;
      }, {});
    };

    const guards = deserializeSet();
    const groups = [];
    const groupsCount = beet__namespace.u32.read(buffer, 0);
    buffer = buffer.slice(4);

    for (let i = 0; i < groupsCount; i++) {
      const label = common.removeEmptyChars(buffer.slice(0, constants.CANDY_GUARD_LABEL_SIZE).toString('utf8'));
      buffer = buffer.slice(constants.CANDY_GUARD_LABEL_SIZE);
      groups.push({
        label,
        guards: deserializeSet()
      });
    }

    return {
      guards,
      groups
    };
  }
  /**
   * Resolves the set of settings that should be used when minting.
   *
   * If no group exists, the `guards` settings will be used.
   * Otherwise, the `guards` settings will act as default settings and
   * the settings of the selected group will override them.
   */


  resolveGroupSettings(guards, groups = [], groupLabel) {
    const availableGroups = groups.map(group => group.label);
    const activeGroup = groups.find(group => group.label === groupLabel);

    if (groupLabel && !activeGroup) {
      throw new errors.SelectedGuardGroupDoesNotExistError(groupLabel, availableGroups);
    }

    if (groups.length === 0) {
      return guards;
    }

    if (!activeGroup) {
      throw new errors.GuardGroupRequiredError(availableGroups);
    }

    const activeGroupGuardsWithoutNullGuards = Object.fromEntries(Object.entries(activeGroup.guards).filter(([, v]) => v != null));
    return { ...guards,
      ...activeGroupGuardsWithoutNullGuards
    };
  }
  /**
   * Parses the arguments and remaining accounts of
   * all relevant guards for the mint instruction.
   */


  parseMintSettings(candyMachine, candyGuard, payer, guardMintSettings, groupLabel, programs = []) {
    const availableGuards = this.forCandyGuardProgram(programs);
    const guardSettings = this.resolveGroupSettings(candyGuard.guards, candyGuard.groups, groupLabel);
    const initialAccumulator = {
      arguments: buffer.Buffer.from([]),
      accountMetas: [],
      signers: []
    };
    return availableGuards.reduce((acc, guard) => {
      var _guardSettings$guard$, _guardMintSettings$gu;

      const settings = (_guardSettings$guard$ = guardSettings[guard.name]) !== null && _guardSettings$guard$ !== void 0 ? _guardSettings$guard$ : null;
      const mintSettings = (_guardMintSettings$gu = guardMintSettings[guard.name]) !== null && _guardMintSettings$gu !== void 0 ? _guardMintSettings$gu : null;
      if (!guard.mintSettingsParser || !settings) return acc;
      const parsedSettings = guard.mintSettingsParser({
        metaplex: this.metaplex,
        settings,
        mintSettings,
        payer,
        candyMachine,
        candyGuard: candyGuard.address,
        programs
      });
      const accounts = this.getAccountMetas(parsedSettings.remainingAccounts);
      const signers = this.getSigners(parsedSettings.remainingAccounts);
      acc.arguments = buffer.Buffer.concat([acc.arguments, parsedSettings.arguments]);
      acc.accountMetas.push(...accounts);
      acc.signers.push(...signers);
      return acc;
    }, initialAccumulator);
  }
  /**
   * Parses the arguments and remaining accounts of
   * the requested guard for the route instruction.
   */


  parseRouteSettings(candyMachine, candyGuard, payer, guard, routeSettings, groupLabel, programs = []) {
    var _guardSettings$guard;

    const guardManifest = this.get(guard);

    if (!guardManifest.routeSettingsParser) {
      throw new errors.GuardRouteNotSupportedError(guard);
    }

    const guardSettings = this.resolveGroupSettings(candyGuard.guards, candyGuard.groups, groupLabel);
    const settings = (_guardSettings$guard = guardSettings[guard]) !== null && _guardSettings$guard !== void 0 ? _guardSettings$guard : null;

    if (!settings) {
      throw new errors.GuardNotEnabledError(guard, groupLabel);
    }

    const parsedSettings = guardManifest.routeSettingsParser({
      metaplex: this.metaplex,
      settings,
      routeSettings,
      payer,
      candyMachine,
      candyGuard: candyGuard.address,
      programs
    });
    return {
      arguments: parsedSettings.arguments,
      accountMetas: this.getAccountMetas(parsedSettings.remainingAccounts),
      signers: this.getSigners(parsedSettings.remainingAccounts)
    };
  }
  /** @internal */


  getAccountMetas(remainingAccounts) {
    return remainingAccounts.map(account => ({
      pubkey: account.isSigner ? account.address.publicKey : account.address,
      isSigner: account.isSigner,
      isWritable: account.isWritable
    }));
  }
  /** @internal */


  getSigners(remainingAccounts) {
    return remainingAccounts.filter(account => account.isSigner).map(account => account.address);
  }

}

exports.CandyMachineGuardsClient = CandyMachineGuardsClient;
//# sourceMappingURL=CandyMachineGuardsClient.cjs.map
