{"version":3,"file":"FeatureFlags.mjs","sources":["../../../src/types/FeatureFlags.ts"],"sourcesContent":["import { Buffer } from 'buffer';\n\nexport type FeatureFlags = boolean[];\n\n/**\n * Serializes an array of boolean into a Buffer. The `byteSize` parameter\n * can be used to create a fixed-size Buffer, otherwise the Buffer will\n * have the minimum amount of bytes required to store the boolean array.\n */\nexport const serializeFeatureFlags = (\n  features: FeatureFlags,\n  byteSize?: number,\n  littleEndian = true\n): Buffer => {\n  const bytes: number[] = [];\n  let currentByte = 0;\n\n  for (let i = 0; i < features.length; i++) {\n    const byteIndex = i % 8;\n    if (littleEndian) {\n      currentByte |= Number(features[i]) << byteIndex;\n    } else {\n      currentByte |= Number(features[i]) >> byteIndex;\n    }\n    if (byteIndex === 7) {\n      bytes.push(currentByte);\n      currentByte = 0;\n    }\n  }\n\n  const buffer = Buffer.from(bytes);\n  return byteSize === undefined ? buffer : Buffer.concat([buffer], byteSize);\n};\n\n/**\n * Parses a Buffer into an array of booleans using the bits\n * of the buffer. The number of flags is required to know\n * how many bits to read and how many booleans to return.\n */\nexport const deserializeFeatureFlags = (\n  buffer: Buffer,\n  numberOfFlags: number,\n  offset = 0,\n  littleEndian = true\n): [FeatureFlags, number] => {\n  const booleans: boolean[] = [];\n  const byteSize = Math.ceil(numberOfFlags / 8);\n  const bytes = buffer.slice(offset, offset + byteSize);\n\n  for (let byte of bytes) {\n    for (let i = 0; i < 8; i++) {\n      if (littleEndian) {\n        booleans.push(Boolean(byte & 1));\n        byte >>= 1;\n      } else {\n        booleans.push(Boolean(byte & 0b1000_0000));\n        byte <<= 1;\n      }\n    }\n  }\n\n  return [booleans.slice(0, numberOfFlags), offset + byteSize];\n};\n"],"names":["serializeFeatureFlags","features","byteSize","littleEndian","bytes","currentByte","i","length","byteIndex","Number","push","buffer","Buffer","from","undefined","concat","deserializeFeatureFlags","numberOfFlags","offset","booleans","Math","ceil","slice","byte","Boolean"],"mappings":";;AAIA;AACA;AACA;AACA;AACA;AACO,MAAMA,qBAAqB,GAAG,CACnCC,QADmC,EAEnCC,QAFmC,EAGnCC,YAAY,GAAG,IAHoB,KAIxB;EACX,MAAMC,KAAe,GAAG,EAAxB,CAAA;EACA,IAAIC,WAAW,GAAG,CAAlB,CAAA;;AAEA,EAAA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,QAAQ,CAACM,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;AACxC,IAAA,MAAME,SAAS,GAAGF,CAAC,GAAG,CAAtB,CAAA;;AACA,IAAA,IAAIH,YAAJ,EAAkB;MAChBE,WAAW,IAAII,MAAM,CAACR,QAAQ,CAACK,CAAD,CAAT,CAAN,IAAuBE,SAAtC,CAAA;AACD,KAFD,MAEO;MACLH,WAAW,IAAII,MAAM,CAACR,QAAQ,CAACK,CAAD,CAAT,CAAN,IAAuBE,SAAtC,CAAA;AACD,KAAA;;IACD,IAAIA,SAAS,KAAK,CAAlB,EAAqB;MACnBJ,KAAK,CAACM,IAAN,CAAWL,WAAX,CAAA,CAAA;AACAA,MAAAA,WAAW,GAAG,CAAd,CAAA;AACD,KAAA;AACF,GAAA;;AAED,EAAA,MAAMM,MAAM,GAAGC,MAAM,CAACC,IAAP,CAAYT,KAAZ,CAAf,CAAA;AACA,EAAA,OAAOF,QAAQ,KAAKY,SAAb,GAAyBH,MAAzB,GAAkCC,MAAM,CAACG,MAAP,CAAc,CAACJ,MAAD,CAAd,EAAwBT,QAAxB,CAAzC,CAAA;AACD,EAvBM;AAyBP;AACA;AACA;AACA;AACA;;AACac,MAAAA,uBAAuB,GAAG,CACrCL,MADqC,EAErCM,aAFqC,EAGrCC,MAAM,GAAG,CAH4B,EAIrCf,YAAY,GAAG,IAJsB,KAKV;EAC3B,MAAMgB,QAAmB,GAAG,EAA5B,CAAA;EACA,MAAMjB,QAAQ,GAAGkB,IAAI,CAACC,IAAL,CAAUJ,aAAa,GAAG,CAA1B,CAAjB,CAAA;EACA,MAAMb,KAAK,GAAGO,MAAM,CAACW,KAAP,CAAaJ,MAAb,EAAqBA,MAAM,GAAGhB,QAA9B,CAAd,CAAA;;AAEA,EAAA,KAAK,IAAIqB,IAAT,IAAiBnB,KAAjB,EAAwB;IACtB,KAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,MAAA,IAAIH,YAAJ,EAAkB;QAChBgB,QAAQ,CAACT,IAAT,CAAcc,OAAO,CAACD,IAAI,GAAG,CAAR,CAArB,CAAA,CAAA;AACAA,QAAAA,IAAI,KAAK,CAAT,CAAA;AACD,OAHD,MAGO;QACLJ,QAAQ,CAACT,IAAT,CAAcc,OAAO,CAACD,IAAI,GAAG,UAAR,CAArB,CAAA,CAAA;AACAA,QAAAA,IAAI,KAAK,CAAT,CAAA;AACD,OAAA;AACF,KAAA;AACF,GAAA;;AAED,EAAA,OAAO,CAACJ,QAAQ,CAACG,KAAT,CAAe,CAAf,EAAkBL,aAAlB,CAAD,EAAmCC,MAAM,GAAGhB,QAA5C,CAAP,CAAA;AACD;;;;"}