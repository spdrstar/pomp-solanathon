import { Buffer } from 'buffer';

/**
 * Serializes an array of boolean into a Buffer. The `byteSize` parameter
 * can be used to create a fixed-size Buffer, otherwise the Buffer will
 * have the minimum amount of bytes required to store the boolean array.
 */
const serializeFeatureFlags = (features, byteSize, littleEndian = true) => {
  const bytes = [];
  let currentByte = 0;

  for (let i = 0; i < features.length; i++) {
    const byteIndex = i % 8;

    if (littleEndian) {
      currentByte |= Number(features[i]) << byteIndex;
    } else {
      currentByte |= Number(features[i]) >> byteIndex;
    }

    if (byteIndex === 7) {
      bytes.push(currentByte);
      currentByte = 0;
    }
  }

  const buffer = Buffer.from(bytes);
  return byteSize === undefined ? buffer : Buffer.concat([buffer], byteSize);
};
/**
 * Parses a Buffer into an array of booleans using the bits
 * of the buffer. The number of flags is required to know
 * how many bits to read and how many booleans to return.
 */

const deserializeFeatureFlags = (buffer, numberOfFlags, offset = 0, littleEndian = true) => {
  const booleans = [];
  const byteSize = Math.ceil(numberOfFlags / 8);
  const bytes = buffer.slice(offset, offset + byteSize);

  for (let byte of bytes) {
    for (let i = 0; i < 8; i++) {
      if (littleEndian) {
        booleans.push(Boolean(byte & 1));
        byte >>= 1;
      } else {
        booleans.push(Boolean(byte & 0b10000000));
        byte <<= 1;
      }
    }
  }

  return [booleans.slice(0, numberOfFlags), offset + byteSize];
};

export { deserializeFeatureFlags, serializeFeatureFlags };
//# sourceMappingURL=FeatureFlags.mjs.map
